models/File.js
```javascript
const mongoose = require('mongoose');

const fileSchema = new mongoose.Schema({
  name: { type: String, required: true },
  path: { type: String, required: true },
  content: { type: String, default: '' },
  language: { type: String, default: 'plaintext' },
  projectId: { type: mongoose.Schema.Types.ObjectId, ref: 'Project', required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('File', fileSchema);
```

---

### `controllers/fileController.js`
```javascript
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const File = require('../models/File');
const Project = require('../models/Project');

// File CRUD operations
exports.createFile = async (req, res) => {
  try {
    const { name, projectId, content, language } = req.body;
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const filePath = path.join(project.name, name);
    const file = new File({
      name,
      path: filePath,
      content: content || '',
      language,
      projectId,
      userId: req.user.id
    });
    await file.save();
    res.json(file);
  } catch (err) {
    console.error(err);
    res.status(500).send('File creation failed');
  }
};

exports.getFiles = async (req, res) => {
  try {
    const { projectId } = req.params;
    const files = await File.find({ projectId, userId: req.user.id });
    res.json(files);
  } catch (err) {
    console.error(err);
    res.status(500).send('Error fetching files');
  }
};

exports.updateFile = async (req, res) => {
  try {
    const { content } = req.body;
    const file = await File.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      { content, updatedAt: Date.now() },
      { new: true }
    );
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    res.json(file);
  } catch (err) {
    console.error(err);
    res.status(500).send('File update failed');
  }
};

// Terminal execution
exports.executeCommand = async (req, res) => {
  try {
    const { command, projectId } = req.body;
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    exec(command, { cwd: project.name }, (error, stdout, stderr) => {
      if (error) {
        return res.status(400).json({ error: stderr });
      }
      res.json({ output: stdout });
    });
  } catch (err) {
    console.error(err);
    res.status(500).send('Command execution failed');
  }
};
```

---

### `services/collaborationService.js`
```javascript
const WebSocket = require('ws');
const File = require('../models/File');

function setupCollaboration(server) {
  const wss = new WebSocket.Server({ server });

  const connections = new Map();

  wss.on('connection', (ws, req) => {
    const fileId = req.url.split('/').pop();
    if (!connections.has(fileId)) {
      connections.set(fileId, new Set());
    }
    connections.get(fileId).add(ws);
    ws.on('message', async (message) => {
      try {
        const data = JSON.parse(message);
        if (data.type === 'edit') {
          // Broadcast changes to all collaborators
          connections.get(fileId).forEach(client => {
            if (client !== ws && client.readyState === WebSocket.OPEN) {
              client.send(JSON.stringify({ type: 'update', changes: data.changes, sender: data.sender }));
            }
          });
          // Update file in database
          await File.findByIdAndUpdate(fileId, {
            content: data.content,
            updatedAt: Date.now()
          });
        }
      } catch (err) {
        console.error('WebSocket Error:', err);
      }
    });
    ws.on('close', () => {
      connections.get(fileId).delete(ws);
      if (connections.get(fileId).size === 0) {
        connections.delete(fileId);
      }
    });
  });

  return wss;
}

module.exports = setupCollaboration;
```

---

### `models/Subscription.js`
```javascript
const mongoose = require('mongoose');

const subscriptionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  plan: { type: String, enum: ['free', 'pro', 'enterprise'], default: 'free' },
  status: { type: String, enum: ['active', 'past_due', 'canceled'], default: 'active' },
  paymentMethod: { type: String },
  currentPeriodEnd: { type: Date },
  cancelAtPeriodEnd: { type: Boolean, default: false },
  stripeCustomerId: { type: String },
  stripeSubscriptionId: { type: String },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

subscriptionSchema.index({ userId: 1 }, { unique: true });

module.exports = mongoose.model('Subscription', subscriptionSchema);
```

---

### `controllers/billingController.js`
```javascript
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const Subscription = require('../models/Subscription');
const User = require('../models/User');

// Create Stripe customer and subscription
exports.createSubscription = async (req, res) => {
  try {
    const { paymentMethodId, plan } = req.body;
    const user = await User.findById(req.user.id);
    // Create or retrieve Stripe customer
    let customer;
    if (user.stripeCustomerId) {
      customer = await stripe.customers.retrieve(user.stripeCustomerId);
    } else {
      customer = await stripe.customers.create({
        email: user.email,
        name: user.name,
        payment_method: paymentMethodId,
        invoice_settings: { default_payment_method: paymentMethodId }
      });
      // Save customer ID to user
      user.stripeCustomerId = customer.id;
      await user.save();
    }
    // Create subscription
    const subscription = await stripe.subscriptions.create({
      customer: customer.id,
      items: [{ price: process.env[`STRIPE_${plan.toUpperCase()}_PRICE_ID`] }],
      expand: ['latest_invoice.payment_intent']
    });
    // Save subscription to database
    const newSubscription = new Subscription({
      userId: req.user.id,
      plan,
      status: 'active',
      stripeCustomerId: customer.id,
      stripeSubscriptionId: subscription.id,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000)
    });
    await newSubscription.save();
    res.json({
      status: subscription.status,
      clientSecret: subscription.latest_invoice.payment_intent.client_secret
    });
  } catch (err) {
    console.error('Subscription Error:', err);
    res.status(500).send('Subscription creation failed');
  }
};

// Handle Stripe webhooks
exports.handleWebhook = async (req, res) => {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error('Webhook Error:', err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  switch (event.type) {
    case 'invoice.payment_succeeded':
      const subscription = event.data.object;
      await Subscription.updateOne(
        { stripeSubscriptionId: subscription.subscription },
        {
          currentPeriodEnd: new Date(subscription.period_end * 1000),
          updatedAt: Date.now()
        }
      );
      break;
    case 'customer.subscription.deleted':
      const deletedSub = event.data.object;
      await Subscription.updateOne(
        { stripeSubscriptionId: deletedSub.id },
        { status: 'canceled', updatedAt: Date.now() }
      );
      break;
    // Handle other events as needed
  }

  res.json({ received: true });
};

// Check trial status and downgrade if needed
exports.checkTrialStatus = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    if (user.subscriptionStatus === 'trial' && new Date() > user.trialEndsAt) {
      user.subscriptionStatus = 'inactive';
      user.subscriptionPlan = 'free';
      await user.save();
    }
    next();
  } catch (err) {
    console.error('Trial Check Error:', err);
    next();
  }
};
```

---

### `middlewares/validation.js`
```javascript
const Joi = require('joi');

// User validation schemas
const userSchema = Joi.object({
  name: Joi.string().min(2).max(30).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(8).required()
});

const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required()
});

// File validation schema
const fileSchema = Joi.object({
  name: Joi.string().required(),
  projectId: Joi.string().required(),
  content: Joi.string().allow(''),
  language: Joi.string().default('plaintext')
});

// Middleware to validate request body
const validate = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.body);
  if (error) {
    return res.status(400).json({
      error: 'Validation Error',
      details: error.details.map(d => d.message)
    });
  }
  next();
};

module.exports = {
  validateUser: validate(userSchema),
  validateLogin: validate(loginSchema),
  validateFile: validate(fileSchema)
};
```

---

### `middlewares/errorHandler.js`
```javascript
function errorHandler(err, req, res, next) {
  console.error(err.stack);

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation Error',
      details: Object.values(err.errors).map(e => e.message)
    });
  }

  if (err.name === 'MongoError' && err.code === 11000) {
    return res.status(400).json({
      error: 'Duplicate Key Error',
      details: 'This value already exists in the database'
    });
  }

  if (err.response?.data) {
    return res.status(502).json({
      error: 'External Service Error',
      details: err.response.data
    });
  }

  res.status(500).json({
    error: 'Server Error',
    message: 'An unexpected error occurred'
  });
}

module.exports = errorHandler;
```

---

### `middlewares/security.js`
```javascript
const rateLimit = require('express-rate-limit');
const csrf = require('csurf');
const helmet = require('helmet');

// Rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});

// CSRF protection
const csrfProtection = csrf({ cookie: true });

// Security headers
const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", 'cdn.jsdelivr.net'],
      styleSrc: ["'self'", "'unsafe-inline'", 'cdn.jsdelivr.net'],
      imgSrc: ["'self'", 'data:', 'blob:'],
      connectSrc: ["'self'", 'api.continue.dev']
    }
  },
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubDomains: true,
    preload: true
  }
});

module.exports = { apiLimiter, csrfProtection, securityHeaders };
```

---

### `tests/auth.test.js`
```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

describe('Authentication', () => {
  beforeEach(async () => {
    await User.deleteMany({});
  });

  it('should register a new user', async () => {
    const res = await request(app)
      .post('/api/v1/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123'
      });
    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('token');
  });

  it('should not register with invalid email', async () => {
    const res = await request(app)
      .post('/api/v1/register')
      .send({
        name: 'Test User',
        email: 'invalid-email',
        password: 'password123'
      });
    expect(res.statusCode).toEqual(400);
    expect(res.body).toHaveProperty('error');
  });

  // Add more tests...
});
```

---

### `tests/file.test.js`
```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');
const Project = require('../models/Project');
const File = require('../models/File');

describe('File Operations', () => {
  let token;
  let projectId;

  beforeAll(async () => {
    // Create test user and get token
    await request(app)
      .post('/api/v1/register')
      .send({
        name: 'File Test User',
        email: 'filetest@example.com',
        password: 'password123'
      });
    const loginRes = await request(app)
      .post('/api/v1/login')
      .send({
        email: 'filetest@example.com',
        password: 'password123'
      });
    token = loginRes.body.token;
    // Create test project
    const projectRes = await request(app)
      .post('/api/v1/projects')
      .set('Authorization', `Bearer ${token}`)
      .send({
        name: 'Test Project',
        description: 'Test project for file operations',
        language: 'javascript'
      });
    projectId = projectRes.body._id;
  });

  it('should create a new file', async () => {
    const res = await request(app)
      .post('/api/v1/files')
      .set('Authorization', `Bearer ${token}`)
      .send({
        name: 'test.js',
        projectId,
        content: 'console.log("Hello");',
        language: 'javascript'
      });
    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('_id');
  });

  // Add more tests...
});
```

---

### `Dockerfile`
```dockerfile
# Build stage
FROM node:18 as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Runtime stage
FROM node:18-slim

WORKDIR /app
COPY --from=builder /app .

ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000
CMD ["node", "server.js"]
```

---

### `.github/workflows/deploy.yml`
```yaml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run build
      - uses: azure/webapps-deploy@v2
        with:
          app-name: 'codefusion'
          slot-name: 'production'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: .
```

---

### `lib/continueClient.ts`
```typescript
import { Continue } from "continue-client";

// Create a singleton instance
let continueInstance: Continue | null = null;

export const getContinueClient = () => {
  if (!continueInstance) {
    continueInstance = new Continue({
      model: "continue-model", // or specify OpenAI, etc.
      contextProvider: async () => {
        return window.editorContext || {};
      },
    });

    void continueInstance.init();
  }

  return continueInstance;
};
```

---

### `hooks/useContinue.ts`
```typescript
import { useEffect, useState } from "react";
import { getContinueClient } from "@/lib/continueClient";

export const useContinue = () => {
  const [continueClient, setContinueClient] = useState<ReturnType<typeof getContinueClient> | null>(null);

  useEffect(() => {
    const client = getContinueClient();
    setContinueClient(client);

    // Clean up listener on unmount
    return () => {
      client.removeAllListeners();
    };
  }, []);

  const registerEditorContext = (context: any) => {
    // Attach current editor context globally for Continue
    (window as any).editorContext = context;
  };

  const onCompletion = (callback: (completion: any) => void) => {
    if (continueClient) {
      continueClient.on("completion", callback);
    }
  };

  return {
    continueClient,
    registerEditorContext,
    onCompletion,
  };
};
```

---

### `contexts/EditorContext.tsx`
```typescript
import { createContext, useContext, useState, useEffect } from "react";
import { useContinue } from "@/hooks/useContinue";

interface EditorContextType {
  activeFile: string;
  projectStructure: string[];
  terminalHistory: string[];
  updateActiveFile: (file: string) => void;
  updateProjectStructure: (structure: string[]) => void;
  updateTerminalHistory: (history: string[]) => void;
}

const EditorContext = createContext<EditorContextType | undefined>(undefined);

export const EditorProvider = ({ children }: { children: React.ReactNode }) => {
  const [activeFile, setActiveFile] = useState("");
  const [projectStructure, setProjectStructure] = useState<string[]>([]);
  const [terminalHistory, setTerminalHistory] = useState<string[]>([]);

  const { registerEditorContext } = useContinue();

  useEffect(() => {
    registerEditorContext({
      files: [{ path: activeFile, content: "" }],
      projectStructure,
      terminalOutput: terminalHistory.join("\n"),
    });
  }, [activeFile, projectStructure, terminalHistory]);

  return (
    <EditorContext.Provider
      value={{
        activeFile,
        projectStructure,
        terminalHistory,
        updateActiveFile: setActiveFile,
        updateProjectStructure: setProjectStructure,
        updateTerminalHistory: setTerminalHistory,
      }}
    >
      {children}
    </EditorContext.Provider>
  );
};

export const useEditorContext = () => {
  const context = useContext(EditorContext);
  if (!context) throw new Error("useEditorContext must be used within EditorProvider");
  return context;
};
```

---

### `components/AIAssistant.tsx`
```typescript
"use client";

import React, { useState } from "react";
import { useContinue } from "@/hooks/useContinue";

export const AIAssistant = () => {
  const [input, setInput] = useState("");
  const [response, setResponse] = useState("");
  const { continueClient } = useContinue();

  const handleSend = async () => {
    if (!input.trim()) return;

    try {
      await continueClient.run(
        {
          messages: [{ role: "user", content: input }],
        },
        (chunk) => {
          setResponse((prev) => prev + chunk.content);
        }
      );
    } catch (error) {
      console.error("Error generating response:", error);
    }
  };

  return (
    <div className="p-4 border rounded-md">
      <h3 className="font-bold mb-2">AI Assistant</h3>
      <textarea
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Ask for help with code..."
        className="w-full p-2 border rounded-md"
      />
      <button onClick={handleSend} className="mt-2 px-4 py-2 bg-blue-500 text-white rounded-md">
        Send
      </button>
      <div className="mt-4 whitespace-pre-wrap">{response}</div>
    </div>
  );
};
```

---

### `types/global.d.ts`
```typescript
declare global {
  interface Window {
    editorContext: {
      files: Array<{
        path: string;
        content: string;
      }>;
      projectStructure: string[];
      terminalOutput: string;
    };
  }
}

export {};
```

---

### `app/layout.tsx`
```typescript
import { EditorProvider } from "@/contexts/EditorContext";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <EditorProvider>{children}</EditorProvider>
      </body>
    </html>
  );
}
```

---

### `components/TestContinueButton.tsx`
```typescript
"use client";

import { useContinue } from "@/hooks/useContinue";

export const TestContinueButton = () => {
  const { continueClient } = useContinue();

  const testPrompt = async () => {
    await continueClient.run(
      {
        messages: [{ role: "user", content: "Write a function to reverse a string in JavaScript" }],
      },
      (chunk) => {
        console.log("Received chunk:", chunk);
      }
    );
  };

  return (
    <button onClick={testPrompt} className="px-4 py-2 bg-green-500 text-white rounded-md">
      Test Continue
    </button>
  );
};
```

---

### `Mermaid Diagram and Related Code`
```typescript
// AI returns Mermaid code in response
const aiResponse = await continueClient.run({
  messages: [{ role: "user", content: "Draw a flowchart of my app architecture" }],
});

// Response includes Mermaid diagram
const mermaidCode = aiResponse.content.includes("```mermaid") ? extractMermaid(aiResponse.content) : null;

if (mermaidCode) {
  // Send back Mermaid code to be rendered
  setMessages((prev) => [...prev, { type: 'mermaid', code: mermaidCode }]);
}

<CodeMirror
  value={mermaidCode}
  extensions={[javascript(), html(), python()]}
  onChange={(value) => setMermaidCode(value)}
/>

await fetch('/api/projects/save-diagram', {
  method: 'POST',
  body: JSON.stringify({ projectId, mermaidCode }),
});

function exportSVG() {
  const svgElement = document.querySelector('.mermaid-diagram svg');
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(svgElement);
  const blob = new Blob([svgString], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'diagram.svg';
  link.click();
}
```

---

### `Mermaid Diagram`
```mermaid
graph TD
  subgraph Frontend
    A[Universal Keyboard UI] -->|Commands| B(Command Dispatcher)
    C[Voice Interface] -->|Transcripts| B
    D[Bot Interface] -->|Natural Language| B
  end

  subgraph Backend
    B -->|Routes| E[API Endpoints]
    E --> F[Command Processor]
    F --> G[File System Abstraction]
    G --> H[Local File System]
    G --> I[Cloud Storage]
    F --> J[Shortcut Manager]
    F --> K[Voice Processor]
    F --> L[Bot Engine]
    F --> M[Cloud Sync]
  end

  subgraph External
    H -->|Files| N[User Devices]
    I -->|Files| O[GitHub/GitLab/S3]
    M -->|Sync| P[WebSockets]
  end
```

---

This is the complete regeneration of the provided codebase, with all files, structures, and content preserved exactly as given. Let me know if you need further assistance or modifications!
