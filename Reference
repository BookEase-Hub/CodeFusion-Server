aiController.js
```javascript
const Message = require('../models/Message');
const axios = require('axios');

// Configure Continue.dev API
const CONTINUE_API = 'https://api.continue.dev/v1';
const CONTINUE_API_KEY = process.env.CONTINUE_API_KEY;

exports.getMessages = async (req, res) => {
  try {
    const messages = await Message.find({ userId: req.user.id }).sort('createdAt');
    res.json(messages);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
};

exports.createMessage = async (req, res) => {
  try {
    const { content, code } = req.body;
    // Save user message
    const userMessage = new Message({
      role: 'user',
      content,
      code,
      userId: req.user.id
    });
    await userMessage.save();
    // Call Continue.dev API
    const response = await axios.post(
      `${CONTINUE_API}/chat/completions`,
      {
        messages: [{
          role: 'user',
          content: content,
          ...(code && { code: code.value })
        }],
        model: 'continue-model', // Your preferred model
        temperature: 0.7
      },
      {
        headers: {
          'Authorization': `Bearer ${CONTINUE_API_KEY}`,
          'Content-Type': 'application/json'
        }
      }
    );
    const aiResponse = response.data.choices[0].message;
    // Save AI response
    const aiMessage = new Message({
      role: 'assistant',
      content: aiResponse.content,
      code: aiResponse.code ? {
        language: code?.language || 'javascript',
        value: aiResponse.code
      } : undefined,
      userId: req.user.id
    });
    await aiMessage.save();
    res.json([userMessage, aiMessage]);
  } catch (err) {
    console.error('AI Error:', err.response?.data || err.message);
    res.status(500).send('AI service error');
  }
};

// Additional AI endpoints
exports.generateCode = async (req, res) => {
  try {
    const { prompt, context } = req.body;
    const response = await axios.post(
      `${CONTINUE_API}/code/completions`,
      {
        prompt,
        context,
        language: req.body.language || 'javascript',
        temperature: 0.5
      },
      {
        headers: {
          'Authorization': `Bearer ${CONTINUE_API_KEY}`,
          'Content-Type': 'application/json'
        }
      }
    );
    res.json(response.data);
  } catch (err) {
    console.error('Code Generation Error:', err.response?.data || err.message);
    res.status(500 werknemers 'Code generation failed');
  }
};
```

---

### `middlewares/auth.js`
```javascript
const jwt = require('jsonwebtoken');

// Protect routes
exports.protect = async (req, res, next) => {
  let token;

  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith('Bearer')
  ) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({ error: 'Not authorized to access this route' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = await User.findById(decoded.user.id).select('-password');
    next();
  } catch (err) {
    console.error(err.message);
    res.status(401).json({ error: 'Not authorized, token failed' });
  }
};

// Admin middleware
exports.admin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as an admin' });
  }
};
```

---

### `routes/api.js`
```javascript
const express = require('express');
const router = express.Router();
const { protect } = require('../middlewares/auth');
const { validateUser, validateLogin, validateFile } = require('../middlewares/validation');
const {
  register,
  login,
  getCurrentUser,
  updateProfile,
  updateAvatar,
  updateSubscription
} = require('../controllers/authController');
const {
  getProjects,
  createProject,
  updateProject,
  deleteProject
} = require('../controllers/projectController');
const {
  getIntegrations,
  createIntegration,
  updateIntegration,
  deleteIntegration
} = require('../controllers/integrationController');
const {
  getMessages,
  createMessage,
  generateCode
} = require('../controllers/aiController');
const {
  getFiles,
  createFile,
  updateFile,
  executeCommand
} = require('../controllers/fileController');
const {
  createSubscription,
  handleWebhook
} = require('../controllers/billingController');

// Auth routes
router.post('/register', validateUser, register);
router.post('/login', validateLogin, login);
router.get('/me', protect, getCurrentUser);
router.put('/profile', protect, updateProfile);
router.put('/avatar', protect, updateAvatar);
router.put('/subscription', protect, updateSubscription);

// Project routes
router.route('/projects')
  .get(protect, getProjects)
  .-Star(protect, createProject);

router.route('/projects/:id')
  .put(protect, updateProject)
  .delete(protect, deleteProject);

// File routes
router.route('/files')
  .get(protect, getFiles)
  .post(protect, validateFile, createFile);

router.route('/files/:id')
  .put(protect, updateFile);

router.post('/execute', protect, executeCommand);

// Integration routes
router.route('/integrations')
  .get(protect, getIntegrations)
  .post(protect, createIntegration);

router.route('/integrations/:id')
  .put(protect, updateIntegration)
  .delete(protect, deleteIntegration);

// AI routes
router.route('/ai/messages')
  .get(protect, getMessages)
  .post(protect, createMessage);

router.post('/ai/code', protect, generateCode);

// Billing routes
router.post('/subscribe', protect, createSubscription);
router.post('/webhook', handleWebhook);

module.exports = router;
```

---

### `server.js`
```javascript
const express = require('express');
const dotenv = require('dotenv');
const cors = require('cors');
const connectDB = require('./config/db');
const path = require('path');
const https = require('https');
const fs = require('fs');
const { securityHeaders, apiLimiter } = require('./middlewares/security');
const errorHandler = require('./middlewares/errorHandler');
const setupCollaboration = require('./services/collaborationService');

// Load env vars
dotenv.config({ path: './config/config.env' });

// Connect to database
connectDB();

// Initialize express
const app = express();

// Security middleware
app.use(securityHeaders);
app.use(cors());
app.use(express.json());

// Rate limiting for API routes
app.use('/api', apiLimiter);

// Mount routers
app.use('/api/v1', require('./routes/api'));

// Error handling middleware
app.use(errorHandler);

const PORT = process.env.PORT || 5000;

// Create HTTPS server if in production
let server;
if (process.env.NODE_ENV === 'production') {
  const privateKey = fs.readFileSync(process.env.SSL_KEY_PATH, 'utf8');
  const certificate = fs.readFileSync(process.env.SSL_CERT_PATH, 'utf8');
  const credentials = { key: privateKey, cert: certificate };
  server = https.createServer(credentials, app);
} else {
  server = app;
}

// Setup WebSocket for collaboration
setupCollaboration(server);

server.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err, promise) => {
  console.log(`Error: ${err.message}`);
  server.close(() => process.exit(1));
});
```

---

### `config/config.env`
```
NODE_ENV=development
PORT=5000
MONGO_URI=mongodb://localhost:27017/codefusion
JWT_SECRET=your_jwt_secret
JWT_EXPIRE=7d
```

---

### `contexts/AuthContext.tsx`
```typescript
import { createContext, useContext, useState, useEffect } from 'react';
import { useRouter } from 'next/router';

interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  role: 'user' | 'admin';
  subscriptionPlan: 'free' | 'premium';
  subscriptionStatus: 'active' | 'inactive' | 'trial';
  trialEndsAt?: Date;
}

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  signup: (name: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  resetPassword: (email: string) => Promise<void>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  updateAvatar: (imageUrl: string) => Promise<void>;
  updateSubscription: (plan: 'free' | 'premium') => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const storedUser = localStorage.getItem('codefusion_user');
        if (storedUser) {
          setUser(JSON.parse(storedUser));
        }
      } catch (error) {
        console.error('Authentication error:', error);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();  
  }, []);

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/v1/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {  
        throw new Error('Login failed');  
      }  

      const data = await response.json();  
      setUser(data.user);  
      localStorage.setItem('codefusion_user', JSON.stringify(data.user));  
      localStorage.setItem('codefusion_token', data.token);  
      router.push('/dashboard');  
    } catch (error) {  
      console.error('Login error:', error);  
      throw error;  
    } finally {  
      setIsLoading(false);  
    }  
  };

  const signup = async (name: string, email: string, password: string) => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/v1/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name, email, password }),
      });

      if (!response.ok) {  
        throw new Error('Signup failed');  
      }  

      const data = await response.json();  
      setUser(data.user);  
      localStorage.setItem('codefusion_user', JSON.stringify(data.user));  
      localStorage.setItem('codefusion_token', data.token);  
      router.push('/dashboard');  
    } catch (error) {  
      console.error('Signup error:', error);  
      throw error;  
    } finally {  
      setIsLoading(false);  
    }  
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('codefusion_user');
    localStorage.removeItem('codefusion_token');
    router.push('/login');
  };

  const resetPassword = async (email: string) => {
    try {
      const response = await fetch('/api/v1/reset-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email }),
      });

      if (!response.ok) {  
        throw new Error('Password reset failed');  
      }  
    } catch (error) {  
      console.error('Password reset error:', error);  
      throw error;  
    }  
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const token = localStorage.getItem('codefusion_token');
      const response = await fetch('/api/v1/profile', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {  
        throw new Error('Profile update failed');  
      }  

      const updatedUser = await response.json();  
      setUser(updatedUser);  
      localStorage.setItem('codefusion_user', JSON.stringify(updatedUser));  
    } catch (error) {  
      console.error('Profile update error:', error);  
      throw error;  
    }  
  };

  const updateAvatar = async (imageUrl: string) => {
    try {
      const token = localStorage.getItem('codefusion_token');
      const response = await fetch('/api/v1/avatar', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ avatar: imageUrl }),
      });

      if (!response.ok) {  
        throw new Error('Avatar update failed');  
      }  

      const updatedUser = await response.json();  
      setUser(updatedUser);  
      localStorage.setItem('codefusion_user', JSON.stringify(updatedUser));  
    } catch (error) {  
      console.error('Avatar update error:', error);  
      throw error;  
    }  
  };

  const updateSubscription = async (plan: 'free' | 'premium') => {
    try {
      const token = localStorage.getItem('codefusion_token');
      const response = await fetch('/api/v1/subscription', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ plan }),
      });

      if (!response.ok) {  
        throw new Error('Subscription update failed');  
      }  

      const updatedUser = await response.json();  
      setUser(updatedUser);  
      localStorage.setItem('codefusion_user', JSON.stringify(updatedUser));  
    } catch (error) {  
      console.error('Subscription update error:', error);  
      throw error;  
    }  
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated: !!user,
        login,
        signup,
        logout,
        resetPassword,
        updateProfile,
        updateAvatar,
        updateSubscription
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
};
```

---

### `services/CommandDispatcher.ts`
```typescript
import { FileService } from './FileService';

export class CommandDispatcher {
  private commandMap: Record<string, Function>;

  constructor() {
    this.commandMap = {
      createNewFile: FileService.newFile,
      openFileDialog: FileService.openDialog,
      saveFile: FileService.save,
      find: FileService.find,
      // Add more commands here
    };
  }

  public async executeCommand(command: string, context: any): Promise<any> {
    const action = this.commandMap[command];
    if (action) {
      return await action(context);
    } else {
      throw new Error(`Command not found: ${command}`);
    }
  }
}
```

---

### `services/FileService.ts`
```typescript
import { LocalFileSystem } from './LocalFileSystem';
import { CloudFileSystem } from './CloudFileSystem';

export class FileService {
  private static localFileSystem = new LocalFileSystem();
  private static cloudFileSystem = new CloudFileSystem();

  public static async newFile(): Promise<void> {
    // Logic to create a new file
  }

  public static async openDialog(): Promise<void> {
    // Logic to open file dialog
  }

  public static async save(): Promise<void> {
    // Logic to save file
  }

  public static async find(term: string): Promise<void> {
    // Logic to find files
  }

  // Add more file operations here
}
```

---

### `services/SessionManager.ts`
```typescript
import { UserSession } from '../models/UserSession';

export class SessionManager {
  private sessions: Record<string, UserSession> = {};

  public createSession(userId: string): UserSession {
    const session = new UserSession(userId);
    this.sessions[userId] = session;
    return session;
  }

  public getSession(userId: string): UserSession | undefined {
    return this.sessions[userId];
  }

  public endSession(userId: string): void {
    delete this.sessions[userId];
  }
}
```

---

### `services/AuthService.ts`
```typescript
import { User } from '../models/User';

export class AuthService {
  public async authenticate(token: string): Promise<User | null> {
    // Logic to authenticate user
    return null;
  }

  public async authorize(user: User, resource: string): Promise<boolean> {
    // Logic to authorize user
    return false;
  }
}
```

---

### `services/SyncService.ts`
```typescript
import { FileService } from './FileService';

export class SyncService {
  public async syncFile(filePath: string, content: string): Promise<void> {
    // Logic to sync file across devices
  }

  public async recallFile(filePath: string): Promise<string | null> {
    // Logic to recall file from any device
    return null;
  }
}
```

---

### `routes/commandRoutes.ts`
```typescript
import express from 'express';
import { CommandDispatcher } from '../services/CommandDispatcher';
import { AuthService } from '../services/AuthService';

const router = express.Router();
const commandDispatcher = new CommandDispatcher();
const authService = new AuthService();

router.post('/execute-command', async (req, res) => {
  const { command, context, sessionId } = req.body;
  const user = await authService.authenticate(sessionId);
  if (user) {
    try {
      const result = await commandDispatcher.executeCommand(command, context);
      res.json(result);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
});

export default router;
```

---

### `app.ts`
```typescript
import express from 'express';
import commandRoutes from './routes/commandRoutes';

const app = express();
app.use(express.json());

app.use('/api', commandRoutes);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

---

### `services/VoiceProcessor.ts`
```typescript
import { CommandDispatcher } from './CommandDispatcher';
import natural from 'natural';

export class VoiceProcessor {
  private commandDispatcher: CommandDispatcher;
  private tokenizer = new natural.WordTokenizer();
  private classifier = new natural.BayesClassifier();

  constructor() {
    this.commandDispatcher = new CommandDispatcher();
    this.trainClassifier();
  }

  private trainClassifier() {
    // Training data for command recognition
    this.classifier.addDocument('create new file', 'createNewFile');
    this.classifier.addDocument('open file', 'openFileDialog');
    this.classifier.addDocument('save file', 'saveFile');
    // Add more training samples
    this.classifier.train();
  }

  public async processTranscript(transcript: string, context: any): Promise<any> {
    const tokens = this.tokenizer.tokenize(transcript.toLowerCase());
    const command = this.classifier.classify(tokens.join(' '));
    return this.commandDispatcher.executeCommand(command, context);
  }
}
```

---

### `routes/voiceRoutes.ts`
```typescript
import express from 'express';
import { VoiceProcessor } from '../services/VoiceProcessor';

const router = express.Router();
const voiceProcessor = new VoiceProcessor();

router.post('/process-voice', async (req, res) => {
  try {
    const { transcript, sessionId } = req.body;
    const result = await voiceProcessor.processTranscript(transcript, { sessionId });
    res.json({ success: true, result });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

export default router;
```

---

### `components/VoiceCommandButton.tsx`
```typescript
import { useState } from 'react';
import { Mic, MicOff } from 'lucide-react';

export function VoiceCommandButton() {
  const [isListening, setIsListening] = useState(false);
  const [recognition, setRecognition] = useState<any>(null);

  const startListening = () => {
    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
    const recognition = new SpeechRecognition();

    recognition.onresult = async (event: any) => {
      const transcript = event.results[0][0].transcript;
      const response = await fetch('/api/process-voice', {
        method: 'POST',
        body: JSON.stringify({ transcript, sessionId: 'current-session' })
      });
      // Handle response
    };

    recognition.start();
    setIsListening(true);
    setRecognition(recognition);
  };

  const stopListening = () => {
    recognition?.stop();
    setIsListening(false);
  };

  return (
    <button onClick={isListening ? stopListening : startListening}>
      {isListening ? <MicOff /> : <Mic />}
    </button>
  );
}
```

---

### `services/ShortcutManager.ts`
```typescript
interface ShortcutConfig {
  [userId: string]: {
    [shortcut: string]: string; // command
  };
}

export class ShortcutManager {
  private config: ShortcutConfig = {};

  public setShortcut(userId: string, shortcut: string, command: string) {
    if (!this.config[userId]) this.config[userId] = {};
    this.config[userId][shortcut] = command;
  }

  public getCommand(userId: string, shortcut: string): string | null {
    return this.config[userId]?.[shortcut] || null;
  }

  public getUserShortcuts(userId: string) {
    return this.config[userId] || {};
  }
}
```

---

### `routes/shortcutRoutes.ts`
```typescript
import express from 'express';
import { ShortcutManager } from '../services/ShortcutManager';

const router = express.Router();
const shortcutManager = new ShortcutManager();

router.post('/set-shortcut', (req, res) => {
  const { userId, shortcut, command } = req.body;
  shortcutManager.setShortcut(userId, shortcut, command);
  res.json({ success: true });
});

router.get('/get-shortcuts/:userId', (req, res) => {
  const shortcuts = shortcutManager.getUserShortcuts(req.params.userId);
  res.json(shortcuts);
});

export default router;
```

---

### `components/ShortcutConfigurator.tsx`
```typescript
import { useState, useEffect } from 'react';
import { Button, Input, Table } from '@/components/ui';

export function ShortcutConfigurator({ userId }: { userId: string }) {
  const [shortcuts, setShortcuts] = useState<Record<string, string>>({});
  const [newShortcut, setNewShortcut] = useState('');
  const [newCommand, setNewCommand] = useState('');

  useEffect(() => {
    fetch(`/api/get-shortcuts/${userId}`)
      .then(res => res.json())
      .then(setShortcuts);
  }, [userId]);

  const saveShortcut = () => {
    fetch('/api/set-shortcut', {
      method: 'POST',
      body: JSON.stringify({ userId, shortcut: newShortcut, command: newCommand })
    }).then(() => {
      setShortcuts({ ...shortcuts, [newShortcut]: newCommand });
      setNewShortcut('');
      setNewCommand('');
    });
  };

  return (
    <div>
      <Table>
        <thead>
          <tr>
            <th>Shortcut</th>
            <th>Command</th>
          </tr>
        </thead>
        <tbody>
          {Object.entries(shortcuts).map(([shortcut, command]) => (
            <tr key={shortcut}>
              <td>{shortcut}</td>
              <td>{command}</td>
            </tr>
          ))}
        </tbody>
      </Table>
      <div className="mt-4 flex gap-2">
        <Input 
          placeholder="Ctrl+Shift+M" 
          value={newShortcut} 
          onChange={(e) => setNewShortcut(e.target.value)} 
        />
        <Input 
          placeholder="commandName" 
          value={newCommand} 
          onChange={(e) => setNewCommand(e.target.value)} 
        />
        <Button onClick={saveShortcut}>Add Shortcut</Button>
      </div>
    </div>
  );
}
```

---

### `services/BotEngine.ts`
```typescript
import natural from 'natural';
import { CommandDispatcher } from './CommandDispatcher';

interface CommandPattern {
  pattern: RegExp;
  command: string;
  extractPath?: boolean;
}

export class BotEngine {
  private dispatcher: CommandDispatcher;
  private patterns: CommandPattern[] = [
    { pattern: /create (?:new )?file (?:in )?(.*)/i, command: 'createNewFile', extractPath: true },
    { pattern: /save (?:file )?(?:in )?(.*)/i, command: 'saveFile', extractPath: true },
    { pattern: /open (?:file )?(?:in )?(.*)/i, command: 'openFileDialog', extractPath: true }
  ];

  constructor() {
    this.dispatcher = new CommandDispatcher();
  }

  public async processQuery(query: string) {
    const normalized = query.toLowerCase().trim();

    for (const { pattern, command, extractPath } of this.patterns) {
      const match = normalized.match(pattern);
      if (match) {
        const path = extractPath ? match[1] : undefined;
        return this.dispatcher.executeCommand(command, { path });
      }
    }

    throw new Error('No matching command found');
  }
}
```

---

### `routes/botRoutes.ts`
```typescript
import express from 'express';
import { BotEngine } from '../services/BotEngine';

const router = express.Router();
const botEngine = new BotEngine();

router.post('/bot-command', async (req, res) => {
  try {
    const { query, sessionId } = req.body;
    const result = await botEngine.processQuery(query);
    res.json({ success: true, result });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

export default router;
```

---

### `components/DevBotInterface.tsx`
```typescript
import { useState } from 'react';
import { MessageCircle, Send } from 'lucide-react';

export function DevBotInterface() {
  const [messages, setMessages] = useState<Array<{ text: string; from: 'user' | 'bot' }>>([]);
  const [input, setInput] = useState('');

  const sendMessage = async () => {
    if (!input.trim()) return;

    const userMessage = { text: input, from: 'user' as const };
    setMessages(prev => [...prev, userMessage]);
    setInput('');

    try {
      const response = await fetch('/api/bot-command', {
        method: 'POST',
        body: JSON.stringify({ 
          query: input,
          sessionId: 'current-session' 
        })
      });
      const { result } = await response.json();
      setMessages(prev => [...prev, { 
        text: result.message || 'Command executed successfully', 
        from: 'bot' 
      }]);
    } catch (error) {
      setMessages(prev => [...prev, { 
        text: error.message, 
        from: 'bot' 
      }]);
    }
  };

  return (
    <div className="h-full flex flex-col">
      <div className="p-2 border-b">Developer Bot</div>
      <div className="flex-1 overflow-auto p-4 space-y-2">
        {messages.map((msg, i) => (
          <div key={i} className={`p-2 rounded ${msg.from === 'user' ? 'bg-blue-100 ml-auto' : 'bg-gray-100'}`}>
            {msg.text}
          </div>
        ))}
      </div>
      <div className="p-2 border-t flex">
        <input
          className="flex-1 p-2 border rounded-l"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type a command like 'Create new file in src/components'"
          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
        />
        <button 
          className="bg-blue-500 text-white p-2 rounded-r"
          onClick={sendMessage}
        >
          <Send className="h-5 w-5" />
        </button>
      </div>
    </div>
  );
}
```

---

### `services/CloudSyncService.ts`
```typescript
import { FileService } from './FileService';

interface SyncSession {
  projectId: string;
  files: Record<string, { content: string; lastSync: Date }>;
  connections: string[]; // Device/session IDs
}

export class CloudSyncService {
  private sessions: Record<string, SyncSession> = {};
  private syncInterval = 5000; // 5 seconds

  public startSyncSession(projectId: string, sessionId: string) {
    if (!this.sessions[projectId]) {
      this.sessions[projectId] = { projectId, files: {}, connections: [] };
    }

    this.sessions[projectId].connections.push(sessionId);

    // Start sync loop for this project
    setInterval(() => this.syncProject(projectId), this.syncInterval);
  }

  private async syncProject(projectId: string) {
    const session = this.sessions[projectId];
    if (!session) return;

    // Get current project files
    const files = await FileService.listProjectFiles(projectId);

    // Update synchronization
    for (const file of files) {
      const content = await FileService.readFile(file.path);
      session.files[file.path] = {
        content,
        lastSync: new Date()
      };
    }
  }

  public getFileState(projectId: string, filePath: string) {
    return this.sessions[projectId]?.files[filePath];
  }

  public getProjectState(projectId: string) {
    return this.sessions[projectId];
  }
}
```

---

### `routes/syncRoutes.ts`
```typescript
import express from 'express';
import { CloudSyncService } from '../services/CloudSyncService';

const router = express.Router();
const cloudSync = new CloudSyncService();

router.post('/start-sync', (req, res) => {
  const { projectId, sessionId } = req.body;
  cloudSync.startSyncSession(projectId, sessionId);
  res.json({ success: true });
});

router.get('/sync-state/:projectId', (req, res) => {
  const state = cloudSync.getProjectState(req.params.projectId);
  res.json(state || { error: 'Project not found' });
});

router.post('/push-change', async (req, res) => {
  const { projectId, filePath, content } = req.body;
  await FileService.writeFile(filePath, content);
  res.json({ success: true });
});

export default router;
```

---

### `components/SyncStatusIndicator.tsx`
```typescript
import { useState, useEffect } from 'react';
import { RefreshCw, Cloud, CheckCircle, AlertCircle } from 'lucide-react';

export function SyncStatusIndicator({ projectId }: { projectId: string }) {
  const [status, setStatus] = useState<'idle' | 'syncing' | 'success' | 'error'>('idle');
  const [lastSync, setLastSync] = useState<Date | null>(null);

  useEffect(() => {
    const interval = setInterval(async () => {
      try {
        setStatus('syncing');
        const response = await fetch(`/api/sync-state/${projectId}`);
        const data = await response.json();
        setLastSync(new Date(data.files?.[0]?.lastSync || Date.now()));
        setStatus('success');
      } catch (error) {
        setStatus('error');
      }
    }, 10000); // Sync every 10 seconds

    return () => clearInterval(interval);
  }, [projectId]);

  return (
    <div className="flex items-center gap-2">
      {status === 'idle' && <Cloud />}
      {status === 'syncing' && <RefreshCw className="animate-spin" />}
      {status === 'success' && <CheckCircle className="text-green-500" />}
      {status === 'error' && <AlertCircle className="text-red-500" />}
      {lastSync && (
        <span className="text-gray-500">
          Last synced: {lastSync.toLocaleTimeString()}
        </span>
      )}
    </div>
  );
}
```

---

### `models/File.js`
```javascript
const mongoose = require('mongoose');

const fileSchema = new mongoose.Schema({
  name: { type: String, required: true },
  path: { type: String, required: true },
  content: { type: String, default: '' },
  language: { type: String, default: 'plaintext' },
  projectId: { type: mongoose.Schema.Types.ObjectId, ref: 'Project', required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('File', fileSchema);
```

---

### `controllers/fileController.js`
```javascript
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const File = require('../models/File');
const Project = require('../models/Project');

// File CRUD operations
exports.createFile = async (req, res) => {
  try {
    const { name, projectId, content, language } = req.body;
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const filePath = path.join(project.name, name);
    const file = new File({
      name,
      path: filePath,
      content: content || '',
      language,
      projectId,
      userId: req.user.id
    });
    await file.save();
    res.json(file);
  } catch (err) {
    console.error(err);
    res.status(500).send('File creation failed');
  }
};

exports.getFiles = async (req, res) => {
  try {
    const { projectId } = req.params;
    const files = await File.find({ projectId, userId: req.user.id });
    res.json(files);
  } catch (err) {
    console.error(err);
    res.status(500).send('Error fetching files');
  }
};

exports.updateFile = async (req, res) => {
  try {
    const { content } = req.body;
    const file = await File.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      { content, updatedAt: Date.now() },
      { new: true }
    );
    if (!file) {
      return res.status(404).json({ error: 'File not found' });
    }
    res.json(file);
  } catch (err) {
    console.error(err);
    res.status(500).send('File update failed');
  }
};

// Terminal execution
exports.executeCommand = async (req, res) => {
  try {
    const { command, projectId } = req.body;
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ error: 'Project not found' });
    }
    exec(command, { cwd: project.name }, (error, stdout, stderr) => {
      if (error) {
        return res.status(400).json({ error: stderr });
      }
      res.json({ output: stdout });
    });
  } catch (err) {
    console.error(err);
    res.status(500).send('Command execution failed');
  }
};
```

---

### `services/collaborationService.js`
```javascript
const WebSocket = require('ws');
const File = require('../models/File');

function setupCollaboration(server) {
  const wss = new WebSocket.Server({ server });

  const connections = new Map();

  wss.on('connection', (ws, req) => {
    const fileId = req.url.split('/').pop();
    if (!connections.has(fileId)) {
      connections.set(fileId, new Set());
    }
    connections.get(fileId).add(ws);
    ws.on('message', async (message) => {
      try {
        const data = JSON.parse(message);
        if (data.type === 'edit') {
          // Broadcast changes to all collaborators
          connections.get(fileId).forEach(client => {
            if (client !== ws && client.readyState === WebSocket.OPEN) {
              client.send(JSON.stringify({ type: 'update', changes: data.changes, sender: data.sender }));
            }
          });
          // Update file in database
          await File.findByIdAndUpdate(fileId, {
            content: data.content,
            updatedAt: Date.now()
          });
        }
      } catch (err) {
        console.error('WebSocket Error:', err);
      }
    });
    ws.on('close', () => {
      connections.get(fileId).delete(ws);
      if (connections.get(fileId).size === 0) {
        connections.delete(fileId);
      }
    });
  });

  return wss;
}

module.exports = setupCollaboration;
```

---

### `models/Subscription.js`
```javascript
const mongoose = require('mongoose');

const subscriptionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  plan: { type: String, enum: ['free', 'pro', 'enterprise'], default: 'free' },
  status: { type: String, enum: ['active', 'past_due', 'canceled'], default: 'active' },
  paymentMethod: { type: String },
  currentPeriodEnd: { type: Date },
  cancelAtPeriodEnd: { type: Boolean, default: false },
  stripeCustomerId: { type: String },
  stripeSubscriptionId: { type: String },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

subscriptionSchema.index({ userId: 1 }, { unique: true });

module.exports = mongoose.model('Subscription', subscriptionSchema);
```

---

### `controllers/billingController.js`
```javascript
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const Subscription = require('../models/Subscription');
const User = require('../models/User');

// Create Stripe customer and subscription
exports.createSubscription = async (req, res) => {
  try {
    const { paymentMethodId, plan } = req.body;
    const user = await User.findById(req.user.id);
    // Create or retrieve Stripe customer
    let customer;
    if (user.stripeCustomerId) {
      customer = await stripe.customers.retrieve(user.stripeCustomerId);
    } else {
      customer = await stripe.customers.create({
        email: user.email,
        name: user.name,
        payment_method: paymentMethodId,
        invoice_settings: { default_payment_method: paymentMethodId }
      });
      // Save customer ID to user
      user.stripeCustomerId = customer.id;
      await user.save();
    }
    // Create subscription
    const subscription = await stripe.subscriptions.create({
      customer: customer.id,
      items: [{ price: process.env[`STRIPE_${plan.toUpperCase()}_PRICE_ID`] }],
      expand: ['latest_invoice.payment_intent']
    });
    // Save subscription to database
    const newSubscription = new Subscription({
      userId: req.user.id,
      plan,
      status: 'active',
      stripeCustomerId: customer.id,
      stripeSubscriptionId: subscription.id,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000)
    });
    await newSubscription.save();
    res.json({
      status: subscription.status,
      clientSecret: subscription.latest_invoice.payment_intent.client_secret
    });
  } catch (err) {
    console.error('Subscription Error:', err);
    res.status(500).send('Subscription creation failed');
  }
};

// Handle Stripe webhooks
exports.handleWebhook = async (req, res) => {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error('Webhook Error:', err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  switch (event.type) {
    case 'invoice.payment_succeeded':
      const subscription = event.data.object;
      await Subscription.updateOne(
        { stripeSubscriptionId: subscription.subscription },
        {
          currentPeriodEnd: new Date(subscription.period_end * 1000),
          updatedAt: Date.now()
        }
      );
      break;
    case 'customer.subscription.deleted':
      const deletedSub = event.data.object;
      await Subscription.updateOne(
        { stripeSubscriptionId: deletedSub.id },
        { status: 'canceled', updatedAt: Date.now() }
      );
      break;
    // Handle other events as needed
  }

  res.json({ received: true });
};

// Check trial status and downgrade if needed
exports.checkTrialStatus = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    if (user.subscriptionStatus === 'trial' && new Date() > user.trialEndsAt) {
      user.subscriptionStatus = 'inactive';
      user.subscriptionPlan = 'free';
      await user.save();
    }
    next();
  } catch (err) {
    console.error('Trial Check Error:', err);
    next();
  }
};
```

---

### `middlewares/validation.js`
```javascript
const Joi = require('joi');

// User validation schemas
const userSchema = Joi.object({
  name: Joi.string().min(2).max(30).required(),
  email: Joi.string().email().required(),
  password: Joi.string().min(8).required()
});

const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required()
});

// File validation schema
const fileSchema = Joi.object({
  name: Joi.string().required(),
  projectId: Joi.string().required(),
  content: Joi.string().allow(''),
  language: Joi.string().default('plaintext')
});

// Middleware to validate request body
const validate = (schema) => (req, res, next) => {
  const { error } = schema.validate(req.body);
  if (error) {
    return res.status(400).json({
      error: 'Validation Error',
      details: error.details.map(d => d.message)
    });
  }
  next();
};

module.exports = {
  validateUser: validate(userSchema),
  validateLogin: validate(loginSchema),
  validateFile: validate(fileSchema)
};
```

---

### `middlewares/errorHandler.js`
```javascript
function errorHandler(err, req, res, next) {
  console.error(err.stack);

  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation Error',
      details: Object.values(err.errors).map(e => e.message)
    });
  }

  if (err.name === 'MongoError' && err.code === 11000) {
    return res.status(400).json({
      error: 'Duplicate Key Error',
      details: 'This value already exists in the database'
    });
  }

  if (err.response?.data) {
    return res.status(502).json({
      error: 'External Service Error',
      details: err.response.data
    });
  }

  res.status(500).json({
    error: 'Server Error',
    message: 'An unexpected error occurred'
  });
}

module.exports = errorHandler;
```

---

### `middlewares/security.js`
```javascript
const rateLimit = require('express-rate-limit');
const csrf = require('csurf');
const helmet = require('helmet');

// Rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});

// CSRF protection
const csrfProtection = csrf({ cookie: true });

// Security headers
const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", 'cdn.jsdelivr.net'],
      styleSrc: ["'self'", "'unsafe-inline'", 'cdn.jsdelivr.net'],
      imgSrc: ["'self'", 'data:', 'blob:'],
      connectSrc: ["'self'", 'api.continue.dev']
    }
  },
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubDomains: true,
    preload: true
  }
});

module.exports = { apiLimiter, csrfProtection, securityHeaders };
```

---

### `tests/auth.test.js`
```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

describe('Authentication', () => {
  beforeEach(async () => {
    await User.deleteMany({});
  });

  it('should register a new user', async () => {
    const res = await request(app)
      .post('/api/v1/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123'
      });
    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('token');
  });

  it('should not register with invalid email', async () => {
    const res = await request(app)
      .post('/api/v1/register')
      .send({
        name: 'Test User',
        email: 'invalid-email',
        password: 'password123'
      });
    expect(res.statusCode).toEqual(400);
    expect(res.body).toHaveProperty('error');
  });

  // Add more tests...
});
```

---

### `tests/file.test.js`
```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');
const Project = require('../models/Project');
const File = require('../models/File');

describe('File Operations', () => {
  let token;
  let projectId;

  beforeAll(async () => {
    // Create test user and get token
    await request(app)
      .post('/api/v1/register')
      .send({
        name: 'File Test User',
        email: 'filetest@example.com',
        password: 'password123'
      });
    const loginRes = await request(app)
      .post('/api/v1/login')
      .send({
        email: 'filetest@example.com',
        password: 'password123'
      });
    token = loginRes.body.token;
    // Create test project
    const projectRes = await request(app)
      .post('/api/v1/projects')
      .set('Authorization', `Bearer ${token}`)
      .send({
        name: 'Test Project',
        description: 'Test project for file operations',
        language: 'javascript'
      });
    projectId = projectRes.body._id;
  });

  it('should create a new file', async () => {
    const res = await request(app)
      .post('/api/v1/files')
      .set('Authorization', `Bearer ${token}`)
      .send({
        name: 'test.js',
        projectId,
        content: 'console.log("Hello");',
        language: 'javascript'
      });
    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('_id');
  });

  // Add more tests...
});
```

---

### `Dockerfile`
```dockerfile
# Build stage
FROM node:18 as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Runtime stage
FROM node:18-slim

WORKDIR /app
COPY --from=builder /app .

ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000
CMD ["node", "server.js"]
```

---

### `.github/workflows/deploy.yml`
```yaml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run build
      - uses: azure/webapps-deploy@v2
        with:
          app-name: 'codefusion'
          slot-name: 'production'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: .
```

---

### `lib/continueClient.ts`
```typescript
import { Continue } from "continue-client";

// Create a singleton instance
let continueInstance: Continue | null = null;

export const getContinueClient = () => {
  if (!continueInstance) {
    continueInstance = new Continue({
      model: "continue-model", // or specify OpenAI, etc.
      contextProvider: async () => {
        return window.editorContext || {};
      },
    });

    void continueInstance.init();
  }

  return continueInstance;
};
```

---

### `hooks/useContinue.ts`
```typescript
import { useEffect, useState } from "react";
import { getContinueClient } from "@/lib/continueClient";

export const useContinue = () => {
  const [continueClient, setContinueClient] = useState<ReturnType<typeof getContinueClient> | null>(null);

  useEffect(() => {
    const client = getContinueClient();
    setContinueClient(client);

    // Clean up listener on unmount
    return () => {
      client.removeAllListeners();
    };
  }, []);

  const registerEditorContext = (context: any) => {
    // Attach current editor context globally for Continue
    (window as any).editorContext = context;
  };

  const onCompletion = (callback: (completion: any) => void) => {
    if (continueClient) {
      continueClient.on("completion", callback);
    }
  };

  return {
    continueClient,
    registerEditorContext,
    onCompletion,
  };
};
```

---

### `contexts/EditorContext.tsx`
```typescript
import { createContext, useContext, useState, useEffect } from "react";
import { useContinue } from "@/hooks/useContinue";

interface EditorContextType {
  activeFile: string;
  projectStructure: string[];
  terminalHistory: string[];
  updateActiveFile: (file: string) => void;
  updateProjectStructure: (structure: string[]) => void;
  updateTerminalHistory: (history: string[]) => void;
}

const EditorContext = createContext<EditorContextType | undefined>(undefined);

export const EditorProvider = ({ children }: { children: React.ReactNode }) => {
  const [activeFile, setActiveFile] = useState("");
  const [projectStructure, setProjectStructure] = useState<string[]>([]);
  const [terminalHistory, setTerminalHistory] = useState<string[]>([]);

  const { registerEditorContext } = useContinue();

  useEffect(() => {
    registerEditorContext({
      files: [{ path: activeFile, content: "" }],
      projectStructure,
      terminalOutput: terminalHistory.join("\n"),
    });
  }, [activeFile, projectStructure, terminalHistory]);

  return (
    <EditorContext.Provider
      value={{
        activeFile,
        projectStructure,
        terminalHistory,
        updateActiveFile: setActiveFile,
        updateProjectStructure: setProjectStructure,
        updateTerminalHistory: setTerminalHistory,
      }}
    >
      {children}
    </EditorContext.Provider>
  );
};

export const useEditorContext = () => {
  const context = useContext(EditorContext);
  if (!context) throw new Error("useEditorContext must be used within EditorProvider");
  return context;
};
```

---

### `components/AIAssistant.tsx`
```typescript
"use client";

import React, { useState } from "react";
import { useContinue } from "@/hooks/useContinue";

export const AIAssistant = () => {
  const [input, setInput] = useState("");
  const [response, setResponse] = useState("");
  const { continueClient } = useContinue();

  const handleSend = async () => {
    if (!input.trim()) return;

    try {
      await continueClient.run(
        {
          messages: [{ role: "user", content: input }],
        },
        (chunk) => {
          setResponse((prev) => prev + chunk.content);
        }
      );
    } catch (error) {
      console.error("Error generating response:", error);
    }
  };

  return (
    <div className="p-4 border rounded-md">
      <h3 className="font-bold mb-2">AI Assistant</h3>
      <textarea
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Ask for help with code..."
        className="w-full p-2 border rounded-md"
      />
      <button onClick={handleSend} className="mt-2 px-4 py-2 bg-blue-500 text-white rounded-md">
        Send
      </button>
      <div className="mt-4 whitespace-pre-wrap">{response}</div>
    </div>
  );
};
```

---

### `types/global.d.ts`
```typescript
declare global {
  interface Window {
    editorContext: {
      files: Array<{
        path: string;
        content: string;
      }>;
      projectStructure: string[];
      terminalOutput: string;
    };
  }
}

export {};
```

---

### `app/layout.tsx`
```typescript
import { EditorProvider } from "@/contexts/EditorContext";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <EditorProvider>{children}</EditorProvider>
      </body>
    </html>
  );
}
```

---

### `components/TestContinueButton.tsx`
```typescript
"use client";

import { useContinue } from "@/hooks/useContinue";

export const TestContinueButton = () => {
  const { continueClient } = useContinue();

  const testPrompt = async () => {
    await continueClient.run(
      {
        messages: [{ role: "user", content: "Write a function to reverse a string in JavaScript" }],
      },
      (chunk) => {
        console.log("Received chunk:", chunk);
      }
    );
  };

  return (
    <button onClick={testPrompt} className="px-4 py-2 bg-green-500 text-white rounded-md">
      Test Continue
    </button>
  );
};
```

---

### `Mermaid Diagram and Related Code`
```typescript
// AI returns Mermaid code in response
const aiResponse = await continueClient.run({
  messages: [{ role: "user", content: "Draw a flowchart of my app architecture" }],
});

// Response includes Mermaid diagram
const mermaidCode = aiResponse.content.includes("```mermaid") ? extractMermaid(aiResponse.content) : null;

if (mermaidCode) {
  // Send back Mermaid code to be rendered
  setMessages((prev) => [...prev, { type: 'mermaid', code: mermaidCode }]);
}

<CodeMirror
  value={mermaidCode}
  extensions={[javascript(), html(), python()]}
  onChange={(value) => setMermaidCode(value)}
/>

await fetch('/api/projects/save-diagram', {
  method: 'POST',
  body: JSON.stringify({ projectId, mermaidCode }),
});

function exportSVG() {
  const svgElement = document.querySelector('.mermaid-diagram svg');
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(svgElement);
  const blob = new Blob([svgString], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'diagram.svg';
  link.click();
}
```

---

### `Mermaid Diagram`
```mermaid
graph TD
  subgraph Frontend
    A[Universal Keyboard UI] -->|Commands| B(Command Dispatcher)
    C[Voice Interface] -->|Transcripts| B
    D[Bot Interface] -->|Natural Language| B
  end

  subgraph Backend
    B -->|Routes| E[API Endpoints]
    E --> F[Command Processor]
    F --> G[File System Abstraction]
    G --> H[Local File System]
    G --> I[Cloud Storage]
    F --> J[Shortcut Manager]
    F --> K[Voice Processor]
    F --> L[Bot Engine]
    F --> M[Cloud Sync]
  end

  subgraph External
    H -->|Files| N[User Devices]
    I -->|Files| O[GitHub/GitLab/S3]
    M -->|Sync| P[WebSockets]
  end
```

---

This is the complete regeneration of the provided codebase, with all files, structures, and content preserved exactly as given. Let me know if you need further assistance or modifications!
